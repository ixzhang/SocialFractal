result_df$breaks == breaks - 2 &
result_df$time == current_time
)
if (length(row_index) > 0) {
# Calculate GVF using the 'gvf' function
gvf_value <- gvf(data_vector, breaks)
result_df$gvf[row_index] <- gvf_value
}
# Find the row in result_df that matches the current ID, breaks, and time
row_index <- which(
result_df$ID == current_id &
result_df$breaks == breaks - 2 &
result_df$time == current_time
)
if (length(row_index) > 0) {
# Calculate GVF using the 'gvf' function
gvf_value <- gvf(data_vector, breaks)
result_df$gvf[row_index] <- gvf_value
}
# Calculate GVF using the 'gvf' function
gvf_value <- gvf(data_vector, breaks)
data_vector
breaks
?getJenksBreaks
gvf <- function(data, num_breaks) {
# Check if BAMMtools package is installed and loaded
if (!requireNamespace("BAMMtools", quietly = TRUE)) {
stop("BAMMtools package is needed for this function to work.
Please install it using install.packages(\"BAMMtools\").")
}
# Calculate Jenks breaks using BAMMtools package
breaks <- BAMMtools::getJenksBreaks(data, num_breaks)
# Calculate total sum of squared deviations (sum of squared errors) from the mean
sdam <- sum((data - mean(data)) ^ 2)
# Calculate within-group sum of squared deviations
sdcm <- 0
for (i in 1:(num_breaks - 1)) {
subset_data <- data[data > breaks[i] & data <= breaks[i + 1]]
sdcm <- sdcm + sum((subset_data - mean(subset_data)) ^ 2)
}
# Calculate GVF metric
gvf_value <- (sdam - sdcm) / sdam
return(gvf_value)
}
#' Find the appropriate number of breaks using Jenks natural breaks optimization
#'
#' This function optimizes the number of breaks for a given dataset using the Jenks natural breaks algorithm.
#' It iterates over different numbers of breaks and calculates the Goodness of Variance Fit (GVF) for each combination of individual and time point.
#' The GVF metric helps determine the number of breaks that best represents the data structure while minimizing variance within groups.
#'
#' @param social_networks A 3D array containing social network data over time.
#'                       Dimensions are individuals (first/second dimension), and time points (third dimension).
#' @param max_breaks The maximum number of breaks to consider. Default is 5.
#' @return A data frame containing the GVF values for different numbers of breaks across individuals and time points.
#' @export
#'
#' @examples
#' # Example usage:
#' # Assuming 'social_network_data' is a 3D array with dimensions [individuals, individuals, time]
#' result <- get_breaks_num(social_network_data, max_breaks = 5)
#' # Explore the results to determine the optimal number of breaks
get_breaks_num <- function(social_networks, max_breaks = 5) {
# Extract unique individual IDs and time points from the array dimension names
individual_ids <- dimnames(social_networks)[[1]]
time_points <- dimnames(social_networks)[[3]]
num_time_points <- length(time_points)
num_individuals <- length(individual_ids)
# Generate a data frame to store GVF values for each combination of individual, time point, and breaks
result_df <- expand.grid(
ID = individual_ids,
breaks = 1:max_breaks,
time = time_points
)
# Iterate over each time point
for (time_idx in seq_along(time_points)) {
current_time <- time_points[time_idx]
# Iterate over each individual
for (individual_idx in seq_along(individual_ids)) {
current_id <- individual_ids[individual_idx]
# Extract the vector excluding the current individual's eigenvector
data_vector <- social_networks[individual_idx, -individual_idx, time_idx]
# Calculate GVF for each possible number of breaks
for (breaks in 3:(max_breaks + 2)) {
# Find the row in result_df that matches the current ID, breaks, and time
row_index <- which(
result_df$ID == current_id &
result_df$breaks == breaks - 2 &
result_df$time == current_time
)
if (length(row_index) > 0) {
# Calculate GVF using the 'gvf' function
gvf_value <- gvf(data_vector, breaks)
result_df$gvf[row_index] <- gvf_value
}
}
}
}
# Return the data frame with GVF values
return(result_df)
}
get_breaks_num(zf_rep1_real)
devtools::document()
rm(list = c("gvf"))
devtools::document()
rm(list = c("get_breaks_num"))
devtools::document()
file.create("R/get_breakpoints.R")
paste0("jenk", 1:3)
get_breakpoints <- function(social_networks, break_num = 3){
individual_ids <- dimnames(social_networks)[[1]]
time_points <- dimnames(social_networks)[[3]]
num_time_points <- length(time_points)
num_individuals <- length(individual_ids)
colnames_jenks <- paste0("jenk", 1:break_num)
mat <- matrix(0, nrow = num_time_points * num_individuals, ncol = break_num + 2)
colnames(mat) <- c('ID', 'time', colnames_jenks)
for (i in 1:num_time_points){
mat[(num_individuals * (i-1)+1):(num_individuals * i),1] <- individual_ids
mat[(num_individuals * (i-1)+1):(num_individuals * i),3] <- time_points[i]
for (j in 1:num_individuals){
v <- social_networks[j, -j, i] # Get the interaction values for individual j
if (sum(v) == 0) next # Skip if there are no interactions
jenk <- getJenksBreaks(v, break_num + 2) # Calculate Jenks natural breaks
mat[(num_individuals * (i-1) + j), colnames_jenks] <- jenk[2:(break_num + 1)]
}
}
}
get_breakpoints(zf_rep1_real)
social_networks[is.na(social_networks)] <- 0
#' Calculate Jenks Breakpoints for Social Network Data
#'
#' This function computes Jenks natural breakpoints for social network data across individuals and time points.
#' The result is a matrix containing breakpoints for each individual at each time point.
#'
#' @param social_networks A 3D array with dimensions [individuals, individuals, time points].
#' @param break_num The number of breaks (clusters) to compute. Default is 3.
#' @return A matrix containing the ID, time point, and Jenks breakpoints for each individual-time combination.
#' @export
#'
#' @examples
#' # Example usage:
#' # Assuming 'social_network_data' is a 3D array with dimensions [individuals, individuals, time]
#' breakpoints <- get_breakpoints(social_network_data, break_num = 3)
#' print(breakpoints)
get_breakpoints <- function(social_networks, break_num = 3){
individual_ids <- dimnames(social_networks)[[1]]
time_points <- dimnames(social_networks)[[3]]
num_time_points <- length(time_points)
num_individuals <- length(individual_ids)
colnames_jenks <- paste0("jenk", 1:break_num)
mat <- matrix(0, nrow = num_time_points * num_individuals, ncol = break_num + 2)
colnames(mat) <- c('ID', 'time', colnames_jenks)
social_networks[is.na(social_networks)] <- 0
for (i in 1:num_time_points){
mat[(num_individuals * (i-1)+1):(num_individuals * i),1] <- individual_ids
mat[(num_individuals * (i-1)+1):(num_individuals * i),3] <- time_points[i]
for (j in 1:num_individuals){
v <- social_networks[j, -j, i] # Get the interaction values for individual j
if (sum(v) == 0) next # Skip if there are no interactions
jenk <- getJenksBreaks(v, break_num + 2) # Calculate Jenks natural breaks
mat[(num_individuals * (i-1) + j), colnames_jenks] <- jenk[2:(break_num + 1)]
}
}
}
get_breakpoints(zf_rep1_real)
#' @param social_networks A 3D array with dimensions [individuals, individuals, time points].
#' @param break_num The number of breaks (clusters) to compute. Default is 3.
#' @return A matrix containing the ID, time point, and Jenks breakpoints for each individual-time combination.
#' @export
#'
#' @examples
#' # Example usage:
#' # Assuming 'social_network_data' is a 3D array with dimensions [individuals, individuals, time]
#' breakpoints <- get_breakpoints(social_network_data, break_num = 3)
#' print(breakpoints)
get_breakpoints <- function(social_networks, break_num = 3){
individual_ids <- dimnames(social_networks)[[1]]
time_points <- dimnames(social_networks)[[3]]
num_time_points <- length(time_points)
num_individuals <- length(individual_ids)
colnames_jenks <- paste0("jenk", 1:break_num)
mat <- matrix(0, nrow = num_time_points * num_individuals, ncol = break_num + 2)
colnames(mat) <- c('ID', 'time', colnames_jenks)
social_networks[is.na(social_networks)] <- 0
for (i in 1:num_time_points){
mat[(num_individuals * (i-1)+1):(num_individuals * i),1] <- individual_ids
mat[(num_individuals * (i-1)+1):(num_individuals * i),3] <- time_points[i]
for (j in 1:num_individuals){
v <- social_networks[j, -j, i] # Get the interaction values for individual j
if (sum(v) == 0) next # Skip if there are no interactions
jenk <- getJenksBreaks(v, break_num + 2) # Calculate Jenks natural breaks
mat[(num_individuals * (i-1) + j), colnames_jenks] <- jenk[2:(break_num + 1)]
}
}
return(mat)
}
get_breakpoints(zf_rep1_real)
dimnames(zf_rep1_real)[[3]]
#' Calculate Jenks Breakpoints for Social Network Data
#'
#' This function computes Jenks natural breakpoints for social network data across individuals and time points.
#' The result is a matrix containing breakpoints for each individual at each time point.
#'
#' @param social_networks A 3D array with dimensions [individuals, individuals, time points].
#' @param break_num The number of breaks (clusters) to compute. Default is 3.
#' @return A matrix containing the ID, time point, and Jenks breakpoints for each individual-time combination.
#' @export
#'
#' @examples
#' # Example usage:
#' # Assuming 'social_network_data' is a 3D array with dimensions [individuals, individuals, time]
#' breakpoints <- get_breakpoints(social_network_data, break_num = 3)
#' print(breakpoints)
get_breakpoints <- function(social_networks, break_num = 3){
individual_ids <- dimnames(social_networks)[[1]]
time_points <- dimnames(social_networks)[[3]]
num_time_points <- length(time_points)
num_individuals <- length(individual_ids)
colnames_jenks <- paste0("jenk", 1:break_num)
mat <- matrix(0, nrow = num_time_points * num_individuals, ncol = break_num + 2)
colnames(mat) <- c('ID', 'time', colnames_jenks)
social_networks[is.na(social_networks)] <- 0
for (i in 1:num_time_points){
mat[(num_individuals * (i-1)+1):(num_individuals * i),1] <- individual_ids
mat[(num_individuals * (i-1)+1):(num_individuals * i),2] <- time_points[i]
for (j in 1:num_individuals){
v <- social_networks[j, -j, i] # Get the interaction values for individual j
if (sum(v) == 0) next # Skip if there are no interactions
jenk <- getJenksBreaks(v, break_num + 2) # Calculate Jenks natural breaks
mat[(num_individuals * (i-1) + j), colnames_jenks] <- jenk[2:(break_num + 1)]
}
}
return(mat)
}
get_breakpoints(zf_rep1_real)
#' @param social_networks A 3D array with dimensions [individuals, individuals, time points].
#' @param break_num The number of breaks (clusters) to compute. Default is 3.
#' @return A matrix containing the ID, time point, and Jenks breakpoints for each individual-time combination.
#' @export
#'
#' @examples
#' # Example usage:
#' # Assuming 'social_network_data' is a 3D array with dimensions [individuals, individuals, time]
#' breakpoints <- get_breakpoints(social_network_data, break_num = 3)
#' print(breakpoints)
get_breakpoints <- function(social_networks, break_num = 3) {
# Extract individual IDs and time points from the array's dimension names
individual_ids <- dimnames(social_networks)[[1]]   # Individuals' identifiers
time_points <- dimnames(social_networks)[[3]]      # Time points in the data
num_time_points <- length(time_points)            # Total number of time points
num_individuals <- length(individual_ids)         # Total number of individuals
# Generate dynamic column names for Jenks breakpoints
colnames_jenks <- paste0("jenk", 1:break_num)      # Column names for breakpoints (e.g., jenk1, jenk2, ...)
# Initialize a matrix to store the results (ID, time, and breakpoints)
breakpoints_matrix <- matrix(
0,                                               # Initialize with zeros
nrow = num_time_points * num_individuals,        # Rows for each individual-time combination
ncol = 2 + break_num                             # Columns for ID, Time, and breakpoints
)
colnames(breakpoints_matrix) <- c("ID", "time", colnames_jenks)  # Assign column names
# Iterate over each time point
for (time_idx in 1:num_time_points) {
# Determine the range of rows in the matrix for the current time point
start_row <- (num_individuals * (time_idx - 1)) + 1
end_row <- num_individuals * time_idx
# Assign individual IDs and time point to the current block of rows
breakpoints_matrix[start_row:end_row, "ID"] <- individual_ids   # Assign individual IDs
breakpoints_matrix[start_row:end_row, "time"] <- time_points[time_idx]  # Assign current time point
# Iterate over each individual within the current time point
for (individual_idx in 1:num_individuals) {
# Extract interaction values for the current individual (excluding their own ID)
interaction_values <- social_networks[individual_idx, -individual_idx, time_idx]
# Skip individuals with no interactions (all zeros)
if (sum(interaction_values) == 0) {
next
}
# Calculate Jenks natural breakpoints for the current set of interaction values
# Note: The function 'getJenksBreaks' returns 'break_num + 2' breakpoints; we extract the middle ones
jenks_breaks <- getJenksBreaks(interaction_values, break_num + 2)
# Ensure jenks_breaks is numeric
jenks_breaks <- as.numeric(jenks_breaks)
# Assign the calculated breakpoints to the corresponding row in the matrix
current_row <- start_row + individual_idx - 1
breakpoints_matrix[current_row, colnames_jenks] <- jenks_breaks[2:(break_num + 1)]
}
}
# Return the matrix of Jenks breakpoints
return(breakpoints_matrix)
}
get_breakpoints(zf_rep1_real)
#' Calculate Jenks Breakpoints for Social Network Data
#'
#' This function computes Jenks natural breakpoints for social network data across individuals and time points.
#' The result is a matrix containing breakpoints for each individual at each time point.
#'
#' @param social_networks A 3D array with dimensions [individuals, individuals, time points].
#' @param break_num The number of breaks (clusters) to compute. Default is 3.
#' @return A matrix containing the ID, time point, and Jenks breakpoints for each individual-time combination.
#' @export
#'
#' @examples
#' # Example usage:
#' # Assuming 'social_network_data' is a 3D array with dimensions [individuals, individuals, time]
#' breakpoints <- get_breakpoints(social_network_data, break_num = 3)
#' print(breakpoints)
get_breakpoints <- function(social_networks, break_num = 3) {
# Extract individual IDs and time points from the array's dimension names
individual_ids <- dimnames(social_networks)[[1]]   # Individuals' identifiers
time_points <- dimnames(social_networks)[[3]]      # Time points in the data
num_time_points <- length(time_points)            # Total number of time points
num_individuals <- length(individual_ids)         # Total number of individuals
# Generate dynamic column names for Jenks breakpoints
colnames_jenks <- paste0("jenk", 1:break_num)      # Column names for breakpoints (e.g., jenk1, jenk2, ...)
# Initialize a matrix to store the results (ID, time, and breakpoints)
breakpoints_matrix <- matrix(
0,                                               # Initialize with zeros
nrow = num_time_points * num_individuals,        # Rows for each individual-time combination
ncol = 2 + break_num                             # Columns for ID, Time, and breakpoints
)
colnames(breakpoints_matrix) <- c("ID", "time", colnames_jenks)  # Assign column names
social_networks[is.na(social_networks)] <- 0
# Iterate over each time point
for (time_idx in 1:num_time_points) {
# Determine the range of rows in the matrix for the current time point
start_row <- (num_individuals * (time_idx - 1)) + 1
end_row <- num_individuals * time_idx
# Assign individual IDs and time point to the current block of rows
breakpoints_matrix[start_row:end_row, "ID"] <- individual_ids   # Assign individual IDs
breakpoints_matrix[start_row:end_row, "time"] <- time_points[time_idx]  # Assign current time point
# Iterate over each individual within the current time point
for (individual_idx in 1:num_individuals) {
# Extract interaction values for the current individual (excluding their own ID)
interaction_values <- social_networks[individual_idx, -individual_idx, time_idx]
# Skip individuals with no interactions (all zeros)
if (sum(interaction_values) == 0) {
next
}
# Calculate Jenks natural breakpoints for the current set of interaction values
# Note: The function 'getJenksBreaks' returns 'break_num + 2' breakpoints; we extract the middle ones
jenks_breaks <- getJenksBreaks(interaction_values, break_num + 2)
# Ensure jenks_breaks is numeric
jenks_breaks <- as.numeric(jenks_breaks)
# Assign the calculated breakpoints to the corresponding row in the matrix
current_row <- start_row + individual_idx - 1
breakpoints_matrix[current_row, colnames_jenks] <- jenks_breaks[2:(break_num + 1)]
}
}
# Return the matrix of Jenks breakpoints
return(breakpoints_matrix)
}
get_breakpoints(zf_rep1_real)
str(get_breakpoints(zf_rep1_real))
table(get_breakpoints(zf_rep1_real))
summary(get_breakpoints(zf_rep1_real))
#' Calculate Jenks Breakpoints for Social Network Data
#'
#' This function computes Jenks natural breakpoints for social network data across individuals and time points.
#' The result is a matrix containing breakpoints for each individual at each time point.
#'
#' @param social_networks A 3D array with dimensions [individuals, individuals, time points].
#' @param break_num The number of breaks (clusters) to compute. Default is 3.
#' @return A matrix containing the ID, time point, and Jenks breakpoints for each individual-time combination.
#' @export
#'
#' @examples
#' # Example usage:
#' # Assuming 'social_network_data' is a 3D array with dimensions [individuals, individuals, time]
#' breakpoints <- get_breakpoints(social_network_data, break_num = 3)
#' print(breakpoints)
get_breakpoints <- function(social_networks, break_num = 3) {
# Extract individual IDs and time points from the array's dimension names
individual_ids <- dimnames(social_networks)[[1]]   # Individuals' identifiers
time_points <- dimnames(social_networks)[[3]]      # Time points in the data
num_time_points <- length(time_points)            # Total number of time points
num_individuals <- length(individual_ids)         # Total number of individuals
# Generate dynamic column names for Jenks breakpoints
colnames_jenks <- paste0("jenk", 1:break_num)      # Column names for breakpoints (e.g., jenk1, jenk2, ...)
# Initialize a data.frame to store the results (ID, time, and breakpoints)
breakpoints_df <- data.frame(
ID = character(num_time_points * num_individuals),
time = character(num_time_points * num_individuals),
stringsAsFactors = FALSE
)
# Add columns for Jenks breakpoints
for (col in colnames_jenks) {
breakpoints_df[[col]] <- numeric(num_time_points * num_individuals)
}
social_networks[is.na(social_networks)] <- 0
# Iterate over each time point
for (time_idx in 1:num_time_points) {
# Determine the range of rows in the data.frame for the current time point
start_row <- (num_individuals * (time_idx - 1)) + 1
end_row <- num_individuals * time_idx
# Assign individual IDs and time point to the current block of rows
breakpoints_df[start_row:end_row, "ID"] <- individual_ids   # Assign individual IDs
breakpoints_df[start_row:end_row, "time"] <- time_points[time_idx]  # Assign current time point
# Iterate over each individual within the current time point
for (individual_idx in 1:num_individuals) {
# Extract interaction values for the current individual (excluding their own ID)
interaction_values <- social_networks[individual_idx, -individual_idx, time_idx]
# Skip individuals with no interactions (all zeros)
if (sum(interaction_values) == 0) {
next
}
# Calculate Jenks natural breakpoints for the current set of interaction values
# Note: The function 'getJenksBreaks' returns 'break_num + 2' breakpoints; we extract the middle ones
jenks_breaks <- getJenksBreaks(interaction_values, break_num + 2)
# Assign the calculated breakpoints to the corresponding row in the data.frame
current_row <- start_row + individual_idx - 1
breakpoints_df[current_row, colnames_jenks] <- jenks_breaks[2:(break_num + 1)]
}
}
# Convert time column to numeric (if necessary)
breakpoints_df$time <- as.numeric(breakpoints_df$time)
# Return the data.frame of Jenks breakpoints
return(breakpoints_df)
}
get_breakpoints(zf_rep1_real)
devtools::document()
file.create("R/relationship_num.R")
load("data/zf_ind.rda")
View(zf_ind)
breakpoints_df <- data.frame(
ID = character(num_time_points * num_individuals),
sex = character(num_time_points * num_individuals),
time = character(num_time_points * num_individuals),
stringsAsFactors = FALSE
)
View(breakpoints_df)
#' Calculate Jenks Breakpoints for Social Network Data
#'
#' This function computes Jenks natural breakpoints for social network data across individuals and time points.
#' The result is a matrix containing breakpoints for each individual at each time point.
#'
#' @param social_networks A 3D array with dimensions [individuals, individuals, time points].
#' @param break_num The number of breaks (clusters) to compute. Default is 3.
#' @return A matrix containing the ID, time point, and Jenks breakpoints for each individual-time combination.
#' @export
#'
#' @examples
#' # Example usage:
#' # Assuming 'social_network_data' is a 3D array with dimensions [individuals, individuals, time]
#' breakpoints <- get_breakpoints(social_network_data, break_num = 3)
#' print(breakpoints)
get_breakpoints <- function(social_networks, sex = NA, break_num = 3) {
# Extract individual IDs and time points from the array's dimension names
individual_ids <- dimnames(social_networks)[[1]]   # Individuals' identifiers
time_points <- dimnames(social_networks)[[3]]      # Time points in the data
num_time_points <- length(time_points)            # Total number of time points
num_individuals <- length(individual_ids)         # Total number of individuals
# Generate dynamic column names for Jenks breakpoints
colnames_jenks <- paste0("jenk", 1:break_num)      # Column names for breakpoints (e.g., jenk1, jenk2, ...)
# Initialize a data.frame to store the results (ID, time, and breakpoints)
breakpoints_df <- data.frame(
ID = character(num_time_points * num_individuals),
sex = character(num_time_points * num_individuals),
time = character(num_time_points * num_individuals),
stringsAsFactors = FALSE
)
# Add columns for Jenks breakpoints
for (col in colnames_jenks) {
breakpoints_df[[col]] <- numeric(num_time_points * num_individuals)
}
social_networks[is.na(social_networks)] <- 0
# Iterate over each time point
for (time_idx in 1:num_time_points) {
# Determine the range of rows in the data.frame for the current time point
start_row <- (num_individuals * (time_idx - 1)) + 1
end_row <- num_individuals * time_idx
# Assign individual IDs and time point to the current block of rows
breakpoints_df[start_row:end_row, "ID"] <- individual_ids   # Assign individual IDs
breakpoints_df[start_row:end_row, "sex"] <- sex
breakpoints_df[start_row:end_row, "time"] <- time_points[time_idx]  # Assign current time point
# Iterate over each individual within the current time point
for (individual_idx in 1:num_individuals) {
# Extract interaction values for the current individual (excluding their own ID)
interaction_values <- social_networks[individual_idx, -individual_idx, time_idx]
# Skip individuals with no interactions (all zeros)
if (sum(interaction_values) == 0) {
next
}
# Calculate Jenks natural breakpoints for the current set of interaction values
# Note: The function 'getJenksBreaks' returns 'break_num + 2' breakpoints; we extract the middle ones
jenks_breaks <- getJenksBreaks(interaction_values, break_num + 2)
# Assign the calculated breakpoints to the corresponding row in the data.frame
current_row <- start_row + individual_idx - 1
breakpoints_df[current_row, colnames_jenks] <- jenks_breaks[2:(break_num + 1)]
}
}
# Convert time column to numeric (if necessary)
breakpoints_df$time <- as.numeric(breakpoints_df$time)
# Return the data.frame of Jenks breakpoints
return(breakpoints_df)
}
get_breakpoints(zf_rep1_real)
sex.information <- zf_ind$sex[zf_ind$QR == dimnames(zf_rep1_real)[[1]]]
dimnames(zf_rep1_real)[[1]]
sex.information <- zf_ind$sex[zf_ind$QR == (dimnames(zf_rep1_real)[[1]])]
zf_ind$QR == (dimnames(zf_rep1_real)[[1]])
sum(zf_ind$QR == (dimnames(zf_rep1_real)[[1]]))
?match
IQ_values <- dimnames(zf_rep1_real)[[1]]
indices <- match(IQ_values, zf_ind$QR)
indices
sex.information <- zf_ind$sex[match(dimnames(zf_rep1_real)[[1]], zf_ind$QR)]
get_breakpoints(zf_rep1_real, sex.information)
col(breakpoints_df)
ncol(breakpoints_df)
breakpoints_df <- get_breakpoints(zf_rep1_real, sex.information)
View(breakpoints_df)
breakpoints_df[, 1:3]
paste0('tier', 1:3, c('', 'same', 'opposite'))
